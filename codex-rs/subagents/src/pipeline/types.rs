//! Core data types for the subagent pipeline transformation workflow.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Structured requirements specification produced by the Spec Parser subagent.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct RequirementsSpec {
    /// Unique identifier for this requirements specification
    pub id: String,
    /// Title or summary of the requirements
    pub title: String,
    /// Detailed description of what needs to be implemented
    pub description: String,
    /// List of acceptance criteria that must be met
    pub acceptance_criteria: Vec<AcceptanceCriterion>,
    /// Technical constraints or considerations
    pub constraints: Vec<String>,
    /// Related files or components that may be affected
    pub related_files: Vec<PathBuf>,
    /// Additional metadata or context
    pub metadata: HashMap<String, String>,
}

/// Individual acceptance criterion with priority and validation requirements
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct AcceptanceCriterion {
    /// Unique identifier for this criterion
    pub id: String,
    /// Description of what must be achieved
    pub description: String,
    /// Priority level (High, Medium, Low)
    pub priority: Priority,
    /// Whether this criterion can be automatically tested
    pub testable: bool,
    /// Optional test scenario description
    pub test_scenario: Option<String>,
}

/// Priority levels for acceptance criteria
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum Priority {
    High,
    Medium,
    Low,
}

/// Proposed code changes generated by the Code Writer subagent.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProposedChanges {
    /// Unique identifier for this change set
    pub id: String,
    /// Reference to the requirements spec this addresses
    pub requirements_id: String,
    /// Individual file changes
    pub changes: Vec<FileChange>,
    /// Implementation rationale and design decisions
    pub rationale: String,
    /// Estimated impact assessment
    pub impact: ImpactAssessment,
    /// Files that were analyzed for context
    pub analyzed_files: Vec<PathBuf>,
}

/// Individual file modification proposal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileChange {
    /// Path to the file being modified
    pub file_path: PathBuf,
    /// Type of change being made
    pub change_type: ChangeType,
    /// The actual content changes
    pub content: String,
    /// Line range if this is a partial modification
    pub line_range: Option<(usize, usize)>,
    /// Reason for this specific change
    pub reason: String,
}

/// Types of file changes that can be proposed
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ChangeType {
    Create,
    Modify,
    Delete,
    Rename { from: PathBuf },
}

/// Assessment of the proposed changes' impact
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImpactAssessment {
    /// Risk level of these changes
    pub risk_level: RiskLevel,
    /// Components that might be affected
    pub affected_components: Vec<String>,
    /// Breaking changes that might occur
    pub breaking_changes: Vec<String>,
    /// Performance implications
    pub performance_notes: Option<String>,
    /// Security considerations
    pub security_notes: Option<String>,
}

/// Risk levels for proposed changes
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
    Critical,
}

/// Test plan and execution results from the Tester subagent.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestPlan {
    /// Unique identifier for this test plan
    pub id: String,
    /// Reference to the requirements spec being tested
    pub requirements_id: String,
    /// Reference to the proposed changes being tested
    pub changes_id: String,
    /// Individual test cases
    pub test_cases: Vec<TestCase>,
    /// Overall testing strategy
    pub strategy: String,
    /// Test execution results
    pub results: Option<TestResults>,
}

/// Individual test case specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCase {
    /// Unique identifier for this test case
    pub id: String,
    /// Name/title of the test case
    pub name: String,
    /// Description of what this test validates
    pub description: String,
    /// Type of test (unit, integration, etc.)
    pub test_type: TestType,
    /// Test execution command or script
    pub execution_command: Option<String>,
    /// Expected outcome description
    pub expected_outcome: String,
    /// Associated acceptance criterion if any
    pub acceptance_criterion_id: Option<String>,
}

/// Types of tests that can be executed
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TestType {
    Unit,
    Integration,
    Functional,
    Performance,
    Security,
    Manual,
}

/// Results of test execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestResults {
    /// Overall execution status
    pub status: TestStatus,
    /// Results for individual test cases
    pub test_case_results: HashMap<String, TestCaseResult>,
    /// Summary of execution
    pub summary: String,
    /// Total execution time
    pub execution_time_ms: Option<u64>,
    /// Any errors or warnings encountered
    pub diagnostics: Vec<TestDiagnostic>,
}

/// Overall test execution status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TestStatus {
    Passed,
    Failed,
    Partial,
    Blocked,
    Skipped,
}

/// Result for an individual test case
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCaseResult {
    /// Whether this test case passed
    pub status: TestStatus,
    /// Output from test execution
    pub output: Option<String>,
    /// Error message if failed
    pub error: Option<String>,
    /// Execution time for this test case
    pub execution_time_ms: Option<u64>,
}

/// Diagnostic information from test execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestDiagnostic {
    /// Severity of this diagnostic
    pub level: DiagnosticLevel,
    /// Diagnostic message
    pub message: String,
    /// File location if applicable
    pub file_path: Option<PathBuf>,
    /// Line number if applicable
    pub line_number: Option<usize>,
}

/// Diagnostic severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DiagnosticLevel {
    Info,
    Warning,
    Error,
    Critical,
}

/// Code review findings from the Reviewer subagent.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewFindings {
    /// Unique identifier for this review
    pub id: String,
    /// Reference to the proposed changes being reviewed
    pub changes_id: String,
    /// Individual review findings
    pub findings: Vec<ReviewFinding>,
    /// Overall review status
    pub status: ReviewStatus,
    /// Summary and recommendations
    pub summary: String,
    /// Reviewer confidence level
    pub confidence: ConfidenceLevel,
}

/// Individual code review finding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReviewFinding {
    /// Unique identifier for this finding
    pub id: String,
    /// Severity of the finding
    pub severity: FindingSeverity,
    /// Category of the finding
    pub category: FindingCategory,
    /// Description of the issue
    pub description: String,
    /// File location of the finding
    pub file_path: PathBuf,
    /// Line range if applicable
    pub line_range: Option<(usize, usize)>,
    /// Suggested resolution
    pub suggestion: Option<String>,
    /// Rule or pattern that triggered this finding
    pub rule_id: Option<String>,
}

/// Severity levels for review findings
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FindingSeverity {
    Info,
    Minor,
    Major,
    Critical,
    Blocker,
}

/// Categories of review findings
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FindingCategory {
    Style,
    Security,
    Performance,
    Maintainability,
    Correctness,
    Documentation,
    Testing,
}

/// Overall review status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReviewStatus {
    Approved,
    ApprovedWithComments,
    RequestChanges,
    Blocked,
}

/// Reviewer confidence in the review
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConfidenceLevel {
    Low,
    Medium,
    High,
}

/// Complete pipeline state combining all subagent outputs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PipelineState {
    /// Current pipeline stage
    pub stage: PipelineStage,
    /// Requirements specification (if available)
    pub requirements: Option<RequirementsSpec>,
    /// Proposed changes (if available)
    pub changes: Option<ProposedChanges>,
    /// Test plan and results (if available)
    pub test_plan: Option<TestPlan>,
    /// Review findings (if available)
    pub review: Option<ReviewFindings>,
    /// Pipeline metadata and execution history
    pub metadata: PipelineMetadata,
}

/// Current stage in the pipeline
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PipelineStage {
    Specification,
    CodeGeneration,
    Testing,
    Review,
    Complete,
}

/// Metadata about pipeline execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PipelineMetadata {
    /// Pipeline execution identifier
    pub execution_id: String,
    /// When the pipeline was started
    pub started_at: String,
    /// When the pipeline was last updated
    pub updated_at: String,
    /// User or system that initiated the pipeline
    pub initiated_by: String,
    /// Custom metadata fields
    pub custom_fields: HashMap<String, String>,
}

impl RequirementsSpec {
    /// Create a new requirements specification
    pub fn new(id: String, title: String, description: String) -> Self {
        Self {
            id,
            title,
            description,
            acceptance_criteria: Vec::new(),
            constraints: Vec::new(),
            related_files: Vec::new(),
            metadata: HashMap::new(),
        }
    }

    /// Add an acceptance criterion
    pub fn add_criterion(&mut self, criterion: AcceptanceCriterion) {
        self.acceptance_criteria.push(criterion);
    }

    /// Get high priority criteria
    pub fn high_priority_criteria(&self) -> Vec<&AcceptanceCriterion> {
        self.acceptance_criteria.iter()
            .filter(|c| c.priority == Priority::High)
            .collect()
    }
}

impl ProposedChanges {
    /// Create a new proposed changes set
    pub fn new(id: String, requirements_id: String, rationale: String) -> Self {
        Self {
            id,
            requirements_id,
            changes: Vec::new(),
            rationale,
            impact: ImpactAssessment {
                risk_level: RiskLevel::Low,
                affected_components: Vec::new(),
                breaking_changes: Vec::new(),
                performance_notes: None,
                security_notes: None,
            },
            analyzed_files: Vec::new(),
        }
    }

    /// Add a file change
    pub fn add_change(&mut self, change: FileChange) {
        self.changes.push(change);
    }

    /// Get changes by type
    pub fn changes_by_type(&self, change_type: &ChangeType) -> Vec<&FileChange> {
        self.changes.iter()
            .filter(|c| std::mem::discriminant(&c.change_type) == std::mem::discriminant(change_type))
            .collect()
    }
}

impl TestPlan {
    /// Create a new test plan
    pub fn new(id: String, requirements_id: String, changes_id: String, strategy: String) -> Self {
        Self {
            id,
            requirements_id,
            changes_id,
            test_cases: Vec::new(),
            strategy,
            results: None,
        }
    }

    /// Add a test case
    pub fn add_test_case(&mut self, test_case: TestCase) {
        self.test_cases.push(test_case);
    }

    /// Get test cases by type
    pub fn test_cases_by_type(&self, test_type: &TestType) -> Vec<&TestCase> {
        self.test_cases.iter()
            .filter(|tc| &tc.test_type == test_type)
            .collect()
    }
}

impl ReviewFindings {
    /// Create a new review findings set
    pub fn new(id: String, changes_id: String) -> Self {
        Self {
            id,
            changes_id,
            findings: Vec::new(),
            status: ReviewStatus::Approved,
            summary: String::new(),
            confidence: ConfidenceLevel::Medium,
        }
    }

    /// Add a finding
    pub fn add_finding(&mut self, finding: ReviewFinding) {
        self.findings.push(finding);
    }

    /// Get findings by severity
    pub fn findings_by_severity(&self, severity: &FindingSeverity) -> Vec<&ReviewFinding> {
        self.findings.iter()
            .filter(|f| &f.severity == severity)
            .collect()
    }

    /// Check if any blocking findings exist
    pub fn has_blocking_findings(&self) -> bool {
        self.findings.iter().any(|f| f.severity == FindingSeverity::Blocker)
    }
}